---
title: 시간복잡도
author: RyuRain
date: 2023-12-02 12:40:00 +0900
categories: [Algorithm, Concept]
tags: [algorithm,timeComplex]
math: true
mermaid: true
image:
  path: /assets/img/posts/algorithm.png
---

# 시간복잡도 분석

알고리즘의 효율을 분석할 때 CPU의 실제 작동시간을 재지도 실행하는 명령문의 개수를 세지도 않는다.
위에 결과는 특정 컴퓨터에 따라, 구현하는 언어에 따라, 프로그래머에 따라 차이가 발생하기 때문이다.
따라서 알고리즘상의 복잡한 세부사항과는 독립적인 측정법이 필요하다.<br>

우리는 이분검색과 단위검색간의 효율성을 측정할 때 두 알고리즘이 실행한 비교연산의 수를 보고 효율성을 판단한다.
이처럼 알고리즘의 실행시간은 단위계산(비교연산)이 많아지면 증가하고, 입력의 크기가 증가하면 단위계산이 많아진다.
따라서 우리는 입력의 크기에 대한 단위 계산의 횟수를 함수로 구하여 알고리즘의 효율성을 판단한다.<br>

## 일정 시간복잡도-T(n)
입력 크기 n에 대해 입력 값에 상관없이 항상 단위연산의 실행 횟수가 일정한 경우 일정 시간복잡도를 사용한다.
```c++
int exchange(int n, int S[]){
  for(int i = 0 ; i < n ; i++)
    for(int j = i + 1 ; j < n ; j++)
      if(S[j] < S[i])
        swap(s[i],s[j]);
}
```
{: file='교환정렬.cpp'}
위 교환 정렬의 경우 단위연산을 S[j]와 S[i]의 비교 입력크기를 n 이라고하면
$$ T(n) = (n-1)+(n-2)+(n-3)+...+1 = {(n-1)n \over 2} $$ 이된다. <br>
하지만 위와 같이 모든 알고리즘을 일정 시간복잡도로 분석결과를 측정할 수 없다. 따라서 아래와 같은 다른 계측 방식이 존재한다.

<br>
```c
int seqsearch(int n, string S[], string key){
  for(int i = 0 ; i < n ; i++){
    if(S[i] == key)
      return i;
  }
  return -1;
}
```
{: file='순차검색.cpp'}

## 최악 시간복잡도-W(n)
입력 크기 n에 대해 알고리즘을 수행하는데 실행하는 단위 연산의 최대 횟수를 측정하는 것이다.<br>
위 순차검색 알고리즘에서 입력크기를 n이라고 하면 최악 시간복잡도는 $$W(n) = n$$이 된다. 

## 평균 시간복잡도-A(n)
최악 시간복잡도 분석으로 최대 시간을 알 수 있지만 어떤 경우는 알고리즘이 평균적으로 얼마나 실행하는 측정하는 것이 더 타당한 경우가 존재한다.
따라서 입력 크기 n에 대해 알고리즘이 수행할 평균 횟수(기대치)을 측정하는 것이다.<br>

위 순차검색 알고리즘에서 입력크기를 n이라고 하고 배열에 키값이 존재할 확률을 P라고 하면 평균 시간복잡도는 
$$ \begin{aligned}  A(n) &= \sum_{k=1}^n (k \times {P \over n}) + n(1 - P) \\\\\\&= {P \over n} \times {n(n+1) \over 2} + n(1-p) = n(1-{P \over 2}) + { P \over 2} \end{aligned}$$이 된다.

## 최선 시간복잡도-B(n)
입력 크기 n에 대해 알고리즘을 수행하는데 실행하는 단위 연산의 최소 횟수를 측정하는 것이다.
위 두 시간복잡도와 달리 분석에 잘 채택되지 않는다.<br>
위 순차검색 알고리즘에서 입력크기를 n이라고 하면 최선 시간복잡도는 $$W(n) = 1$$이 된다.

## 차수 

### Big-O O(n)

### Omega Ω(n)

### Theta Θ(n) 

### small-o o(n)

